// Static TTA: Fixed-size LoRA adapter (rank=4)
// Standard approach for comparison

fn main() {
    let optimizer = 2.0;
    let learning_rate = 0.01;
    let beta1 = 0.9;
    let beta2 = 0.999;
    let epsilon = 0.00000001;
    
    print("Static TTA (fixed rank=4)...");
    
    // Load backbone (frozen)
    load_safetensors_named W1 = "output/backbone_weights.safetensors" : "W1";
    load_safetensors_named b1 = "output/backbone_weights.safetensors" : "b1";
    load_safetensors_named W2 = "output/backbone_weights.safetensors" : "W2";
    load_safetensors_named b2 = "output/backbone_weights.safetensors" : "b2";
    
    let backbone_checksum = sum(W1 * W1) + sum(W2 * W2);
    
    // Load data
    load_safetensors_named X_clean = "data/stream_clean.safetensors" : "x";
    load_safetensors_named Y_clean = "data/stream_clean.safetensors" : "y";
    load_safetensors_named T_clean = "data/stream_clean.safetensors" : "t";
    load_safetensors_named Phase_clean = "data/stream_clean.safetensors" : "phase";
    load_safetensors_named Intensity_clean = "data/stream_clean.safetensors" : "intensity";
    
    load_safetensors_named X_drift = "data/stream_drift.safetensors" : "x";
    load_safetensors_named Y_drift = "data/stream_drift.safetensors" : "y";
    load_safetensors_named Y_drift_oh = "data/stream_drift.safetensors" : "y_onehot";
    load_safetensors_named T_drift = "data/stream_drift.safetensors" : "t";
    load_safetensors_named Phase_drift = "data/stream_drift.safetensors" : "phase";
    load_safetensors_named Intensity_drift = "data/stream_drift.safetensors" : "intensity";
    
    // Phase 1: Clean (no adapter)
    let z1_clean = matmul(X_clean, W1) + b1;
    let h1_clean = relu(z1_clean);
    let z2_clean = matmul(h1_clean, W2) + b2;
    let pred_clean = softmax(z2_clean);
    
    // Phase 2: Drift with STATIC LoRA (rank=4)
    learn lora_A = rand_tensor(128.0, 4.0) * 0.01;
    learn lora_B = rand_tensor(4.0, 10.0) * 0.0;
    
    let batch_size = 512.0;
    let epochs = 1.0;
    
    epoch epochs batch X_drift, Y_drift_oh with batch_size -> x_batch, y_batch {
        let z1 = matmul(x_batch, W1) + b1;
        let h1 = relu(z1);
        let lora_delta = matmul(lora_A, lora_B);
        let z2 = matmul(h1, W2) + matmul(h1, lora_delta) + b2;
        let pred = softmax(z2);
        
        let error = pred - y_batch;
        let loss = mean(error * error);
        minimize loss;
    }
    
    // Final predictions on drift
    let z1_drift = matmul(X_drift, W1) + b1;
    let h1_drift = relu(z1_drift);
    let lora_final = matmul(lora_A, lora_B);
    let z2_drift = matmul(h1_drift, W2) + matmul(h1_drift, lora_final) + b2;
    let pred_drift = softmax(z2_drift);
    
    // Verify backbone frozen
    let checksum_final = sum(W1 * W1) + sum(W2 * W2);
    let checksum_diff = abs(checksum_final - backbone_checksum);
    print("Backbone checksum diff:");
    print(checksum_diff);
    
    // Save results
    save_safetensors {
        pred_probs: pred_clean,
        y_true: Y_clean,
        t: T_clean,
        phase: Phase_clean,
        intensity: Intensity_clean
    }, "output/eval_static_clean.safetensors";
    
    save_safetensors {
        pred_probs: pred_drift,
        y_true: Y_drift,
        t: T_drift,
        phase: Phase_drift,
        intensity: Intensity_drift,
        lora_A: lora_A,
        lora_B: lora_B
    }, "output/eval_static_drift.safetensors";
    
    print("Static TTA results saved.");
    return 0.0;
}

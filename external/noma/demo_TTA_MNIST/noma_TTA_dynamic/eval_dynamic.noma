// Dynamic TTA: Uses NOMA's alloc/realloc for adaptive capacity
// Demonstrates runtime topology changes with optimizer state preservation

fn main() {
    let optimizer = 2.0;
    let learning_rate = 0.01;
    let beta1 = 0.9;
    let beta2 = 0.999;
    let epsilon = 0.00000001;
    
    print("Dynamic TTA with alloc/realloc...");
    
    // Load backbone (frozen)
    load_safetensors_named W1 = "output/backbone_weights.safetensors" : "W1";
    load_safetensors_named b1 = "output/backbone_weights.safetensors" : "b1";
    load_safetensors_named W2 = "output/backbone_weights.safetensors" : "W2";
    load_safetensors_named b2 = "output/backbone_weights.safetensors" : "b2";
    
    let backbone_checksum = sum(W1 * W1) + sum(W2 * W2);
    
    // Load data
    load_safetensors_named X_clean = "data/stream_clean.safetensors" : "x";
    load_safetensors_named Y_clean = "data/stream_clean.safetensors" : "y";
    load_safetensors_named T_clean = "data/stream_clean.safetensors" : "t";
    load_safetensors_named Phase_clean = "data/stream_clean.safetensors" : "phase";
    load_safetensors_named Intensity_clean = "data/stream_clean.safetensors" : "intensity";
    
    load_safetensors_named X_drift = "data/stream_drift.safetensors" : "x";
    load_safetensors_named Y_drift = "data/stream_drift.safetensors" : "y";
    load_safetensors_named Y_drift_oh = "data/stream_drift.safetensors" : "y_onehot";
    load_safetensors_named T_drift = "data/stream_drift.safetensors" : "t";
    load_safetensors_named Phase_drift = "data/stream_drift.safetensors" : "phase";
    load_safetensors_named Intensity_drift = "data/stream_drift.safetensors" : "intensity";
    
    // Phase 1: Clean (no adapter)
    let z1_clean = matmul(X_clean, W1) + b1;
    let h1_clean = relu(z1_clean);
    let z2_clean = matmul(h1_clean, W2) + b2;
    let pred_clean = softmax(z2_clean);
    
    // Phase 2: Drift detected - ALLOC minimal adapter (rank=2)
    print("Drift detected: allocating LoRA rank=2...");
    learn lora_A = rand_tensor(128.0, 2.0) * 0.01;
    learn lora_B = rand_tensor(2.0, 10.0) * 0.0;
    
    // Train phase 1: gradual drift (first half)
    // Use larger batch_size so 2 phases â‰ˆ same compute as static's 1 epoch
    let batch_size = 1024.0;
    let adapt_epochs = 1.0;
    
    // First adaptation pass with rank=2
    epoch adapt_epochs batch X_drift, Y_drift_oh with batch_size -> x_batch, y_batch {
        let z1 = matmul(x_batch, W1) + b1;
        let h1 = relu(z1);
        let lora_delta = matmul(lora_A, lora_B);
        let z2 = matmul(h1, W2) + matmul(h1, lora_delta) + b2;
        let pred = softmax(z2);
        
        let error = pred - y_batch;
        let loss = mean(error * error);
        minimize loss;
    }
    
    // REALLOC to larger capacity (rank=4) - preserves existing weights and optimizer state
    print("Increasing capacity: realloc LoRA to rank=4...");
    realloc lora_A = [128, 4];
    realloc lora_B = [4, 10];
    
    // Continue training with increased capacity
    epoch adapt_epochs batch X_drift, Y_drift_oh with batch_size -> x_batch, y_batch {
        let z1 = matmul(x_batch, W1) + b1;
        let h1 = relu(z1);
        let lora_delta = matmul(lora_A, lora_B);
        let z2 = matmul(h1, W2) + matmul(h1, lora_delta) + b2;
        let pred = softmax(z2);
        
        let error = pred - y_batch;
        let loss = mean(error * error);
        minimize loss;
    }
    
    // Final predictions on drift
    let z1_drift = matmul(X_drift, W1) + b1;
    let h1_drift = relu(z1_drift);
    let lora_final = matmul(lora_A, lora_B);
    let z2_drift = matmul(h1_drift, W2) + matmul(h1_drift, lora_final) + b2;
    let pred_drift = softmax(z2_drift);
    
    // Verify backbone frozen
    let checksum_final = sum(W1 * W1) + sum(W2 * W2);
    let checksum_diff = abs(checksum_final - backbone_checksum);
    print("Backbone checksum diff:");
    print(checksum_diff);
    
    // Save results
    save_safetensors {
        pred_probs: pred_clean,
        y_true: Y_clean,
        t: T_clean,
        phase: Phase_clean,
        intensity: Intensity_clean
    }, "output/eval_dynamic_clean.safetensors";
    
    save_safetensors {
        pred_probs: pred_drift,
        y_true: Y_drift,
        t: T_drift,
        phase: Phase_drift,
        intensity: Intensity_drift,
        lora_A: lora_A,
        lora_B: lora_B
    }, "output/eval_dynamic_drift.safetensors";
    
    print("Dynamic TTA results saved.");
    return 0.0;
}
